clear all;
close all;

%%%% FOR THE DYNAMICS x(k+1)=x(k)+u_x(k), x(k+1)=x(k)+u_y(k) %%%%

% Constraints on state space
bound_x = [1 5];
bound_y = [1 5];
bound = [bound_x; bound_y];

%Constraints on the input space
bound_u = [-2 0; -1 0; 1 0; 2 0; 0 -2; 0 -1; 0 1; 0 2];
n_u = numel(bound_u)/2;

% Space discretization
n_x = 5;
n_y = 5;

d_x=(bound_x(:,2)-bound_x(:,1))./(n_x); % size of the interval
d_y=(bound_y(:,2)-bound_y(:,1))./(n_y);
d_states = [d_x;d_y];

%%%%% Barrier Certificate = d-norm(x_i-x_j)-L %%%%%
d=1; % Distance to be maintained
L=1; % Parameter for abstraction of barrier

load('Controlled_System1');
load('Controlled_System2');
%load('Delta3');
%load('Delta4');
%load('Delta5');

tic
%%% Composition of Controlled system
iter = 0;
Delta=logical(sparse(n_x*n_y*n_x*n_y*n_u*n_u,n_x*n_y*n_x*n_y))
p2 = waitbar(0,'Abstraction in progress...');
% No of For loops depends on the number of sub systems
for i1=1:n_x
    waitbar(i1/n_x,p2,sprintf('Computing the abstraction of the source subsystem - %2.2f',i1/n_x))
    for i2=1:n_y       
        for i3=1:n_x
            for i4=1:n_y
                for h1=1:n_u
                    for h2=1:n_u
                        for ip1=1:n_x
                            for ip2=1:n_y
                                for ip3=1:n_x
                                    for ip4=1:n_y
                                        row_1 = (i1-1)*n_y*n_u+(i2-1)*n_u+h1;
                                        col_1 = (ip1-1)*n_y+ip2;
                                        if(controlled_Delta1(row_1,col_1))
                                            r1=[ip1;ip2];
                                        else
                                            r1=[100;100];
                                        end
                                        row_2 = (i3-1)*n_y*n_u+(i4-1)*n_u+h2;
                                        col_2 = (ip3-1)*n_y+ip4;
                                        if(controlled_Delta2(row_2,col_2))
                                            r2=[ip3;ip4];
                                        else
                                            r2=[-100;-100];
                                        end
                                        % Euclidean distance and -1 for abs of barrier
                                                                                                
                                        B = (d-sqrt(((r1(1)-r2(1))^2+(r1(2)-r2(2))^2)))-L;
                                        if (B >= 0)
                                            Delta((i1-1)*n_y*n_x*n_y*n_u*n_u+(i2-1)*n_x*n_y*n_u*n_u+(i3-1)*n_y*n_u*n_u+(i4-1)*n_u*n_u+(h1-1)*n_u+h2,(ip1-1)*n_y*n_x*n_y+(ip2-1)*n_x*n_y+(ip3-1)*n_y+ip4)=1;
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
end

% Controller Synthesis
Cont=logical(zeros((n_x)*n_y*n_x*n_y,(n_u)*n_u)); % create the matrix structure (defined only with 0,1) 
for i=1:(n_x)*n_y % checking admissible modes for any state
    for h=1:(n_u) % for any control mode
        succ=find(Delta((i-1)*n_u+h,:));
        if ~isempty(succ)
          Cont(i,h)=1;
        end
    end
end
ContA=Cont;